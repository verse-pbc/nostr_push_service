# Example K8s Secret structure for Nostr Push Service
# This file shows the structure - DO NOT commit actual secrets to git!
# Use SealedSecrets or external secret management in production

apiVersion: v1
kind: Secret
metadata:
  name: nostr-push-secret
  namespace: nostr-push
type: Opaque
data:
  # Service private key for NIP-44 decryption (base64 encoded)
  app-nip29-relay-private-key: <base64_encoded_private_key>
  
  # Redis connection string (base64 encoded)
  redis-connection-string: <base64_encoded_redis_url>
  
  # Firebase service account JSON files (base64 encoded)
  # These will be mounted as actual files in the container
  firebase-nostrpushdemo-credentials: <base64_encoded_service_account_json>
  firebase-universes-credentials: <base64_encoded_service_account_json>

---
# How to create this secret from files:

# Method 1: Using kubectl directly
kubectl create secret generic nostr-push-secret \
  --from-file=firebase-nostrpushdemo-credentials=./firebase-service-account-nostrpushdemo.json \
  --from-file=firebase-universes-credentials=./firebase-service-account-universes.json \
  --from-literal=app-nip29-relay-private-key="your_private_key_hex" \
  --from-literal=redis-connection-string="redis://your-redis-host:6379" \
  --namespace=nostr-push

# Method 2: For SealedSecrets (recommended for GitOps)
kubectl create secret generic nostr-push-secret --dry-run=client -o yaml \
  --from-file=firebase-nostrpushdemo-credentials=./firebase-service-account-nostrpushdemo.json \
  --from-file=firebase-universes-credentials=./firebase-service-account-universes.json \
  --from-literal=app-nip29-relay-private-key="your_private_key_hex" \
  --from-literal=redis-connection-string="redis://your-redis-host:6379" \
  | kubeseal -o yaml > sealed-secret.yaml

# Note: K8s automatically base64 encodes the files when creating the secret.
# The secret values are then mounted as actual JSON files in the pod at:
# - /app/secrets/firebase-nostrpushdemo.json
# - /app/secrets/firebase-universes.json