<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Push Notification Test - Plur Push Service</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
            max-width: 600px;
            width: 100%;
        }
        
        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }
        
        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }
        
        .section {
            margin-bottom: 30px;
            padding: 20px;
            background: #f7f7f7;
            border-radius: 8px;
        }
        
        .section h2 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #555;
        }
        
        .input-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            color: #666;
            font-size: 14px;
        }
        
        input, select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }
        
        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
            margin-right: 10px;
            margin-top: 10px;
        }
        
        button:hover {
            background: #5a67d8;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .status {
            padding: 15px;
            border-radius: 6px;
            margin-top: 20px;
            font-size: 14px;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .logs {
            background: #1e1e1e;
            color: #0f0;
            padding: 15px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 20px;
        }
        
        .log-entry {
            margin-bottom: 5px;
        }
        
        .hidden {
            display: none;
        }
        
        .key-display {
            background: #f0f0f0;
            padding: 10px;
            border-radius: 4px;
            word-break: break-all;
            font-family: monospace;
            font-size: 12px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ”” Push Notification Tester</h1>
        <p class="subtitle">Test push notification registration with Plur Push Service</p>
        
        <div class="section">
            <h2>ðŸ“¡ Relay Configuration</h2>
            <div class="input-group">
                <label for="relayUrl">Relay URL:</label>
                <input type="text" id="relayUrl" value="wss://communities.nos.social" />
            </div>
        </div>

        <div class="section">
            <h2>ðŸ”‘ Nostr Keys</h2>
            <button id="generateKeys">Generate New Keys</button>
            <button id="useExtension">Use Nostr Extension (NIP-07)</button>
            <div id="keyInfo" class="hidden">
                <div class="key-display">
                    <strong>Public Key:</strong> <span id="pubkeyDisplay"></span>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>ðŸ“± Push Notifications</h2>
            <div class="input-group">
                <label for="fcmToken">FCM Token:</label>
                <input type="text" id="fcmToken" placeholder="Click 'Get FCM Token' to retrieve" readonly />
            </div>
            <button id="getFcmToken">Get FCM Token</button>
            <button id="register">Register for Push (Kind 3079)</button>
            <button id="deregister">Deregister Push (Kind 3080)</button>
            <div id="notificationStatus" class="status info hidden" style="margin-top: 10px;"></div>
        </div>

        <div class="section">
            <h2>ðŸ”” Subscriptions</h2>
            <div class="input-group">
                <label for="filterType">Filter Type:</label>
                <select id="filterType">
                    <option value="kind">By Event Kind</option>
                    <option value="author">By Author</option>
                    <option value="custom">Custom JSON Filter</option>
                </select>
            </div>
            <div class="input-group" id="kindInput">
                <label for="kindNumber">Event Kind Number:</label>
                <input type="number" id="kindNumber" placeholder="e.g., 1 for text notes" value="1" />
            </div>
            <div class="input-group hidden" id="authorInput">
                <label for="authorPubkey">Author Public Key (hex):</label>
                <input type="text" id="authorPubkey" placeholder="Enter author's public key in hex" />
            </div>
            <div class="input-group hidden" id="customInput">
                <label for="customFilter">Custom Filter JSON:</label>
                <input type="text" id="customFilter" placeholder='{"kinds":[1],"limit":10}' />
            </div>
            <button id="subscribe">Add Subscription (Kind 3081)</button>
            <button id="unsubscribe">Remove Subscription (Kind 3082)</button>
        </div>

        <div class="section">
            <h2>ðŸ“¬ Test Events</h2>
            <button id="sendTextNote">Send Text Note (Kind 1)</button>
            <button id="sendDM">Send DM to Self (Kind 1059)</button>
            <button id="sendMention">Send Mention to Self</button>
        </div>

        <div id="status" class="status hidden"></div>
        
        <div class="logs">
            <div id="logContent">
                <div class="log-entry">Ready to connect...</div>
            </div>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-messaging-compat.js"></script>
    
    <!-- Nostr Tools -->
    <script src="https://unpkg.com/nostr-tools@2.1.0/lib/nostr.bundle.js"></script>
    
    <!-- Firebase Configuration -->
    <script src="firebase-config.js"></script>
    
    <script>
        // Global variables
        let relay = null;
        let privateKey = null;
        let publicKey = null;
        let messaging = null;
        let currentFcmToken = null;
        const { SimplePool, getPublicKey, generatePrivateKey, finalizeEvent, getEventHash } = window.NostrTools;

        // Initialize Firebase
        function initializeFirebase() {
            try {
                // Check if config is provided
                if (!window.firebaseConfig || window.firebaseConfig.apiKey === "YOUR_API_KEY") {
                    log('Firebase not configured. Using test tokens only.', 'warning');
                    document.getElementById('getFcmToken').disabled = true;
                    document.getElementById('getFcmToken').textContent = 'Firebase Not Configured';
                    document.getElementById('fcmToken').value = 'test-token-123';
                    document.getElementById('fcmToken').readOnly = false;
                    return false;
                }

                // Initialize Firebase
                firebase.initializeApp(firebaseConfig);
                messaging = firebase.messaging();

                // Handle foreground messages
                messaging.onMessage((payload) => {
                    log(`Received foreground message: ${payload.notification?.title}`, 'info');
                    showStatus(`New notification: ${payload.notification?.title}`, 'info');
                    
                    // Optionally show notification even when app is in foreground
                    if (Notification.permission === 'granted') {
                        new Notification(payload.notification?.title || 'New Event', {
                            body: payload.notification?.body || 'You have a new notification',
                            icon: '/icon-192x192.png',
                            tag: payload.data?.nostrEventId || 'nostr-notification',
                        });
                    }
                });

                log('Firebase initialized successfully', 'success');
                return true;
            } catch (error) {
                log(`Firebase initialization failed: ${error.message}`, 'error');
                document.getElementById('getFcmToken').disabled = true;
                return false;
            }
        }

        // Logging
        function log(message, type = 'info') {
            const logContent = document.getElementById('logContent');
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            const timestamp = new Date().toLocaleTimeString();
            entry.textContent = `[${timestamp}] ${message}`;
            logContent.appendChild(entry);
            logContent.scrollTop = logContent.scrollHeight;
            console.log(message);
        }

        function showStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.className = `status ${type}`;
            status.textContent = message;
            status.classList.remove('hidden');
            setTimeout(() => status.classList.add('hidden'), 5000);
        }

        // Connect to relay
        async function connectRelay() {
            const relayUrl = document.getElementById('relayUrl').value;
            if (relay) {
                relay.close();
            }
            
            try {
                const pool = new SimplePool();
                relay = await pool.ensureRelay(relayUrl);
                log(`Connected to relay: ${relayUrl}`, 'success');
                showStatus('Connected to relay!', 'success');
                return true;
            } catch (error) {
                log(`Failed to connect: ${error.message}`, 'error');
                showStatus('Failed to connect to relay', 'error');
                return false;
            }
        }

        // Generate keys
        document.getElementById('generateKeys').addEventListener('click', () => {
            privateKey = generatePrivateKey();
            publicKey = getPublicKey(privateKey);
            document.getElementById('pubkeyDisplay').textContent = publicKey;
            document.getElementById('keyInfo').classList.remove('hidden');
            log(`Generated new keypair. Public key: ${publicKey.substring(0, 16)}...`);
            showStatus('Generated new keys!', 'success');
        });

        // Use NIP-07 extension
        document.getElementById('useExtension').addEventListener('click', async () => {
            if (!window.nostr) {
                showStatus('No Nostr extension found. Please install Alby or nos2x.', 'error');
                return;
            }
            
            try {
                publicKey = await window.nostr.getPublicKey();
                privateKey = null; // Extension will sign for us
                document.getElementById('pubkeyDisplay').textContent = publicKey;
                document.getElementById('keyInfo').classList.remove('hidden');
                log(`Using extension. Public key: ${publicKey.substring(0, 16)}...`);
                showStatus('Connected to Nostr extension!', 'success');
            } catch (error) {
                showStatus('Failed to get public key from extension', 'error');
            }
        });

        // Create and sign event
        async function createAndSignEvent(kind, content, tags = []) {
            if (!publicKey) {
                showStatus('Please generate or load keys first', 'error');
                return null;
            }

            const event = {
                kind: kind,
                pubkey: publicKey,
                created_at: Math.floor(Date.now() / 1000),
                tags: tags,
                content: content
            };

            if (privateKey) {
                // Self-sign
                event.id = getEventHash(event);
                event.sig = finalizeEvent(event, privateKey).sig;
            } else if (window.nostr) {
                // Use extension
                const signedEvent = await window.nostr.signEvent(event);
                return signedEvent;
            } else {
                showStatus('No way to sign event', 'error');
                return null;
            }

            return event;
        }

        // Publish event to relay
        async function publishEvent(event) {
            if (!relay) {
                const connected = await connectRelay();
                if (!connected) return false;
            }

            try {
                await relay.publish(event);
                log(`Published event kind ${event.kind}: ${event.id.substring(0, 16)}...`);
                return true;
            } catch (error) {
                log(`Failed to publish: ${error.message}`, 'error');
                return false;
            }
        }

        // Get FCM Token
        document.getElementById('getFcmToken').addEventListener('click', async () => {
            if (!messaging) {
                showStatus('Firebase not initialized', 'error');
                return;
            }

            try {
                // Request notification permission
                const permission = await Notification.requestPermission();
                if (permission !== 'granted') {
                    showStatus('Notification permission denied', 'error');
                    return;
                }

                // Register service worker
                const registration = await navigator.serviceWorker.register('/firebase-messaging-sw.js');
                log('Service Worker registered', 'success');

                // Get FCM token
                const token = await messaging.getToken({
                    serviceWorkerRegistration: registration,
                    vapidKey: window.vapidKey
                });

                if (token) {
                    currentFcmToken = token;
                    document.getElementById('fcmToken').value = token;
                    log(`FCM Token retrieved: ${token.substring(0, 20)}...`, 'success');
                    showStatus('FCM token retrieved successfully!', 'success');
                    
                    // Show notification status
                    document.getElementById('notificationStatus').textContent = 'âœ… Ready to receive push notifications';
                    document.getElementById('notificationStatus').classList.remove('hidden');
                } else {
                    log('No FCM token available', 'error');
                    showStatus('Failed to get FCM token', 'error');
                }
            } catch (error) {
                log(`Error getting FCM token: ${error.message}`, 'error');
                showStatus(`Error: ${error.message}`, 'error');
            }
        });

        // Register for push notifications
        document.getElementById('register').addEventListener('click', async () => {
            const token = document.getElementById('fcmToken').value;
            if (!token || token === 'test-token-123') {
                // For testing, allow test tokens
                const useTestToken = confirm('No real FCM token. Use test token for development?');
                if (!useTestToken) return;
            }
            
            const event = await createAndSignEvent(3079, token);
            if (event && await publishEvent(event)) {
                showStatus('Registered for push notifications!', 'success');
                localStorage.setItem('fcmToken', token);
            }
        });

        // Deregister
        document.getElementById('deregister').addEventListener('click', async () => {
            const token = document.getElementById('fcmToken').value;
            if (!token) {
                showStatus('No FCM token to deregister', 'error');
                return;
            }
            
            const event = await createAndSignEvent(3080, token);
            if (event && await publishEvent(event)) {
                showStatus('Deregistered from push notifications!', 'success');
                localStorage.removeItem('fcmToken');
                
                // Delete token from Firebase
                if (messaging && currentFcmToken === token) {
                    try {
                        await messaging.deleteToken();
                        log('FCM token deleted from Firebase', 'success');
                    } catch (error) {
                        log(`Error deleting FCM token: ${error.message}`, 'error');
                    }
                }
                
                document.getElementById('fcmToken').value = '';
                currentFcmToken = null;
                document.getElementById('notificationStatus').classList.add('hidden');
            }
        });

        // Subscribe with filter
        document.getElementById('subscribe').addEventListener('click', async () => {
            const filterType = document.getElementById('filterType').value;
            let filter = {};

            if (filterType === 'kind') {
                const kind = parseInt(document.getElementById('kindNumber').value);
                filter = { kinds: [kind] };
            } else if (filterType === 'author') {
                const author = document.getElementById('authorPubkey').value;
                if (!author) {
                    showStatus('Please enter an author public key', 'error');
                    return;
                }
                filter = { authors: [author] };
            } else {
                try {
                    filter = JSON.parse(document.getElementById('customFilter').value);
                } catch (e) {
                    showStatus('Invalid JSON filter', 'error');
                    return;
                }
            }

            const event = await createAndSignEvent(3081, JSON.stringify(filter));
            if (event && await publishEvent(event)) {
                showStatus('Added subscription!', 'success');
            }
        });

        // Unsubscribe
        document.getElementById('unsubscribe').addEventListener('click', async () => {
            const filterType = document.getElementById('filterType').value;
            let filter = {};

            if (filterType === 'kind') {
                const kind = parseInt(document.getElementById('kindNumber').value);
                filter = { kinds: [kind] };
            } else if (filterType === 'author') {
                const author = document.getElementById('authorPubkey').value;
                filter = { authors: [author] };
            } else {
                filter = JSON.parse(document.getElementById('customFilter').value);
            }

            const event = await createAndSignEvent(3082, JSON.stringify(filter));
            if (event && await publishEvent(event)) {
                showStatus('Removed subscription!', 'success');
            }
        });

        // Send test text note
        document.getElementById('sendTextNote').addEventListener('click', async () => {
            const event = await createAndSignEvent(1, `Test note at ${new Date().toISOString()}`);
            if (event && await publishEvent(event)) {
                showStatus('Sent text note!', 'success');
            }
        });

        // Send DM to self
        document.getElementById('sendDM').addEventListener('click', async () => {
            if (!publicKey) {
                showStatus('Please generate keys first', 'error');
                return;
            }
            const event = await createAndSignEvent(
                1059, 
                `Test DM to myself at ${new Date().toISOString()}`,
                [['p', publicKey]]
            );
            if (event && await publishEvent(event)) {
                showStatus('Sent DM to yourself!', 'success');
            }
        });

        // Send mention
        document.getElementById('sendMention').addEventListener('click', async () => {
            if (!publicKey) {
                showStatus('Please generate keys first', 'error');
                return;
            }
            const event = await createAndSignEvent(
                1, 
                `Mentioning myself: nostr:${publicKey}`,
                [['p', publicKey]]
            );
            if (event && await publishEvent(event)) {
                showStatus('Sent mention!', 'success');
            }
        });

        // Filter type change handler
        document.getElementById('filterType').addEventListener('change', (e) => {
            document.getElementById('kindInput').classList.toggle('hidden', e.target.value !== 'kind');
            document.getElementById('authorInput').classList.toggle('hidden', e.target.value !== 'author');
            document.getElementById('customInput').classList.toggle('hidden', e.target.value !== 'custom');
        });

        // Auto-connect on load
        window.addEventListener('load', () => {
            // Initialize Firebase
            initializeFirebase();
            
            // Check for saved token
            const savedToken = localStorage.getItem('fcmToken');
            if (savedToken) {
                document.getElementById('fcmToken').value = savedToken;
                currentFcmToken = savedToken;
                log(`Restored saved FCM token: ${savedToken.substring(0, 20)}...`);
            }
            
            // Connect to relay
            setTimeout(connectRelay, 1000);
        });
    </script>
</body>
</html>