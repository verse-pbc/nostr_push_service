<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nostr Push Dev Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
            background: #2a2a2a;
            color: #e0e0e0;
            padding: 10px;
            font-size: 13px;
        }
        
        .container {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 12px;
            max-width: 800px;
            margin: 0 auto;
        }
        
        h1 {
            color: #fff;
            font-size: 16px;
            margin-bottom: 8px;
            font-weight: normal;
        }
        
        .info-bar {
            background: #2a3f5f;
            padding: 6px 8px;
            margin-bottom: 12px;
            border-radius: 3px;
            font-size: 11px;
            color: #aaa;
        }
        
        .info-bar code {
            color: #4fc3f7;
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .section {
            background: #222;
            border: 1px solid #333;
            padding: 8px;
            border-radius: 3px;
        }
        
        .section h2 {
            font-size: 12px;
            margin-bottom: 6px;
            color: #4fc3f7;
            font-weight: normal;
        }
        
        button {
            background: #4fc3f7;
            color: #000;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            margin-right: 6px;
            margin-bottom: 6px;
            font-family: inherit;
        }
        
        button:hover:not(:disabled) {
            background: #29b6f6;
        }
        
        button:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }
        
        button.danger {
            background: #e91e63;
            color: white;
        }
        
        button.danger:hover {
            background: #c2185b;
        }
        
        .status-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            margin-left: 6px;
        }
        
        .status-badge.active {
            background: #4caf50;
            color: white;
        }
        
        .status-badge.inactive {
            background: #666;
            color: #ccc;
        }
        
        textarea {
            width: 100%;
            padding: 6px;
            background: #333;
            border: 1px solid #555;
            color: #e0e0e0;
            border-radius: 3px;
            font-size: 11px;
            font-family: monospace;
            resize: vertical;
            min-height: 40px;
        }
        
        .logs {
            background: #000;
            color: #0f0;
            padding: 8px;
            border-radius: 3px;
            font-family: monospace;
            font-size: 10px;
            height: 120px;
            overflow-y: auto;
            border: 1px solid #333;
        }
        
        .log-entry {
            margin-bottom: 2px;
        }
        
        .log-entry.error {
            color: #f44336;
        }
        
        .log-entry.warning {
            color: #ff9800;
        }
        
        .log-entry.info {
            color: #03a9f4;
        }
        
        .log-entry.success {
            color: #4caf50;
        }
        
        .pubkey {
            font-family: monospace;
            font-size: 10px;
            color: #888;
            word-break: break-all;
            margin: 4px 0;
        }
        
        .hidden {
            display: none;
        }
        
        .debug-info {
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 6px;
            margin-top: 8px;
            border-radius: 3px;
            font-size: 10px;
            font-family: monospace;
            color: #888;
        }
        
        .debug-info div {
            margin: 2px 0;
        }
        
        .quick-start {
            background: #2a3f5f;
            border-left: 3px solid #4fc3f7;
            padding: 8px;
            margin-bottom: 12px;
            font-size: 11px;
        }
        
        .quick-start ol {
            margin: 4px 0 0 20px;
            padding: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîî Nostr Push Notification Dev Tool</h1>
        
        <div class="info-bar">
            <strong>Architecture:</strong> 
            Keys in localStorage ‚Ä¢ Token-pubkey immutable pairing ‚Ä¢ Only original registrant can deregister
        </div>

        <div class="quick-start">
            <strong>Quick Test:</strong>
            <ol>
                <li>Register for Push Notifications</li>
                <li>Subscribe to Chats</li>
                <li>Open another browser and Send to Relay</li>
                <li>You should receive a push notification!</li>
            </ol>
        </div>

        <div class="grid">
            <div class="section">
                <h2>üîë Identity</h2>
                <div class="pubkey" style="word-break: break-all;">npub: <span id="pubkey" style="font-size: 0.8em;">generating...</span></div>
                <div class="pubkey" style="word-break: break-all;">nsec: <span id="privkey" style="font-size: 0.8em;">generating...</span></div>
            </div>
            
            <div class="section">
                <h2>üì± Push Notifications</h2>
                <button id="register" onclick="registerForPush()">Register for Push</button>
                <button id="deregister" onclick="deregisterPush()" disabled>Deregister</button>
                <span id="pushStatus" class="status-badge inactive">Not Registered</span>
            </div>
        </div>

        <div class="grid">
            <div class="section">
                <h2>üí¨ Chat Subscriptions</h2>
                <button id="subscribe" onclick="subscribeToChats()" disabled>Subscribe to Chats</button>
                <button id="unsubscribe" onclick="unsubscribeFromChats()" disabled>Unsubscribe</button>
                <span id="subStatus" class="status-badge inactive">Not Subscribed</span>
            </div>
            
            <div class="section">
                <h2>‚úâÔ∏è Send Test</h2>
                <textarea id="message" placeholder="Test message..."></textarea>
                <button onclick="sendTestMessage()">Send to Relay</button>
            </div>
        </div>

        <div class="section">
            <h2>üìã Activity Log</h2>
            <div class="logs" id="logs"></div>
        </div>

        <div class="debug-info">
            <div><strong>Service Workers:</strong> <span id="swCount">0</span> active</div>
            <div><strong>FCM Token:</strong> <span id="fcmToken">none</span></div>
            <div><strong>Relay:</strong> <span id="relayStatus">disconnected</span></div>
            <button class="danger" onclick="clearAllData()">Clear All Data & Service Workers</button>
        </div>
    </div>

    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-messaging-compat.js"></script>
    
    <!-- Nostr Tools -->
    <script src="nostr.bundle.js"></script>

    <script>
        // Global variables
        let pool = null;
        let privateKey = null;
        let publicKey = null;
        let messaging = null;
        let currentFcmToken = null;
        let isRegistered = false;
        let isSubscribed = false;
        let vapidPublicKey = null;
        const relayUrl = 'wss://communities.nos.social';
        
        // Nostr tools functions (will be initialized after library loads)
        let SimplePool, getPublicKey, generatePrivateKey, finalizeEvent, getEventHash;

        // Auto-initialize on load
        window.addEventListener('load', async () => {
            log('Initializing...', 'info');
            
            // Initialize nostr-tools functions
            if (window.NostrTools) {
                const tools = window.NostrTools;
                SimplePool = tools.SimplePool;
                getPublicKey = tools.getPublicKey;
                generatePrivateKey = tools.generatePrivateKey;
                finalizeEvent = tools.finishEvent || tools.finalizeEvent;
                getEventHash = tools.getEventHash;
                pool = new SimplePool();
            } else {
                log('NostrTools not loaded!', 'error');
                return;
            }
            
            // Generate or restore keys
            generateKeys();
            
            // Initialize Firebase
            await initializeFirebase();
            
            // Connect to relay
            await connectToRelay();
            
            // Check registration status
            checkRegistrationStatus();
            
            // Subscribe to incoming events for debugging
            subscribeToIncomingEvents();
            
            // Count service workers
            updateServiceWorkerCount();
        });

        function generateKeys() {
            // Check for existing key
            const storedKey = localStorage.getItem('privateKey');
            
            if (storedKey) {
                // Stored as hex string
                privateKey = storedKey;
                // Get public key - both are hex strings
                publicKey = window.NostrTools.getPublicKey(privateKey);
                const npub = window.NostrTools.nip19.npubEncode(publicKey);
                log(`Restored existing keypair: ${npub.substring(0, 30)}...`, 'info');
            } else {
                // Generate new key - in this version, returns hex string directly
                privateKey = window.NostrTools.generatePrivateKey();
                localStorage.setItem('privateKey', privateKey);
                // Get public key - both are hex strings
                publicKey = window.NostrTools.getPublicKey(privateKey);
                const npub = window.NostrTools.nip19.npubEncode(publicKey);
                log(`Generated new keypair: ${npub.substring(0, 30)}...`, 'success');
            }
            
            // Convert to bech32 formats for display
            const npub = window.NostrTools.nip19.npubEncode(publicKey);
            const nsec = window.NostrTools.nip19.nsecEncode(privateKey);
            
            // Update UI with full keys for testing
            document.getElementById('pubkey').textContent = npub;
            document.getElementById('privkey').textContent = nsec;
        }

        async function initializeFirebase() {
            try {
                const response = await fetch('/config/fcm.json', { cache: 'no-store' });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    log(`FCM config error: ${response.status} - ${errorText.substring(0, 100)}`, 'error');
                    return false;
                }
                
                const responseText = await response.text();
                
                let config;
                try {
                    config = JSON.parse(responseText);
                } catch (e) {
                    log(`Invalid FCM config JSON: ${e.message}`, 'error');
                    log(`Response: ${responseText.substring(0, 200)}`, 'error');
                    return false;
                }
                
                if (!config.apiKey || config.apiKey === "") {
                    log('Firebase not configured. Using test mode.', 'warning');
                    currentFcmToken = 'test-token-' + Math.random().toString(36).substring(7);
                    document.getElementById('fcmToken').textContent = currentFcmToken.substring(0, 20) + '...';
                    return true;
                }
                
                firebase.initializeApp(config);
                messaging = firebase.messaging();
                vapidPublicKey = config.vapidPublicKey;
                
                // Handle foreground messages
                messaging.onMessage((payload) => {
                    log(`Message received: ${payload.data?.title || 'Notification'}`, 'success');
                    
                    // Show notification even in foreground
                    if ('Notification' in window && Notification.permission === 'granted') {
                        const notification = new Notification(
                            payload.data?.title || 'New Message',
                            {
                                body: payload.data?.body || '',
                                icon: '/favicon.ico'
                            }
                        );
                        
                        notification.onclick = () => {
                            window.focus();
                            notification.close();
                        };
                    }
                });
                
                log('Firebase initialized', 'success');
                return true;
            } catch (error) {
                log(`Firebase init failed: ${error.message}`, 'error');
                return false;
            }
        }

        async function connectToRelay() {
            try {
                if (!pool) {
                    log('Pool not initialized', 'error');
                    return;
                }
                await pool.ensureRelay(relayUrl);
                
                document.getElementById('relayStatus').textContent = relayUrl;
                log(`Connected to relay: ${relayUrl}`, 'success');
            } catch (error) {
                log(`Relay connection failed: ${error.message}`, 'error');
                document.getElementById('relayStatus').textContent = 'error';
            }
        }

        async function checkRegistrationStatus() {
            // First check registration status from Nostr
            await checkRegistrationFromNostr();
            
            // Then check subscription status from Nostr
            await checkSubscriptionFromNostr();
        }
        
        async function checkRegistrationFromNostr() {
            try {
                // Query for both registration (3079) and deregistration (3080) events
                const filter = {
                    kinds: [3079, 3080],
                    authors: [publicKey],
                    limit: 10
                };
                
                const events = await pool.list([relayUrl], [filter]);
                
                if (events && events.length > 0) {
                    // Sort by created_at to get the most recent event
                    events.sort((a, b) => b.created_at - a.created_at);
                    const latestEvent = events[0];
                    
                    // Check if the latest event is a registration or deregistration
                    if (latestEvent.kind === 3079) {
                        // Latest event is a registration
                        currentFcmToken = latestEvent.content || 'registered';
                        isRegistered = true;
                        updatePushUI(true);
                        localStorage.setItem('fcmToken', currentFcmToken);
                        localStorage.setItem('fcmTokenOwner', publicKey);
                        document.getElementById('fcmToken').textContent = currentFcmToken.substring(0, 20) + '...';
                        log('Found active registration from Nostr', 'info');
                    } else if (latestEvent.kind === 3080) {
                        // Latest event is a deregistration
                        currentFcmToken = null;
                        isRegistered = false;
                        updatePushUI(false);
                        localStorage.removeItem('fcmToken');
                        localStorage.removeItem('fcmTokenOwner');
                        document.getElementById('fcmToken').textContent = '';
                        log('Found deregistration from Nostr', 'info');
                    }
                } else {
                    // No registration events found - check localStorage as fallback
                    const savedToken = localStorage.getItem('fcmToken');
                    const savedOwner = localStorage.getItem('fcmTokenOwner');
                    
                    if (savedToken && savedOwner === publicKey) {
                        currentFcmToken = savedToken;
                        isRegistered = true;
                        updatePushUI(true);
                        document.getElementById('fcmToken').textContent = savedToken.substring(0, 20) + '...';
                    } else {
                        isRegistered = false;
                        updatePushUI(false);
                    }
                }
            } catch (error) {
                log(`Failed to check registration status: ${error.message}`, 'error');
                // Fall back to localStorage
                const savedToken = localStorage.getItem('fcmToken');
                const savedOwner = localStorage.getItem('fcmTokenOwner');
                
                if (savedToken && savedOwner === publicKey) {
                    currentFcmToken = savedToken;
                    isRegistered = true;
                    updatePushUI(true);
                    document.getElementById('fcmToken').textContent = savedToken.substring(0, 20) + '...';
                } else {
                    isRegistered = false;
                    updatePushUI(false);
                }
            }
        }
        
        async function checkSubscriptionFromNostr() {
            try {
                // Query for both subscription (3081) and unsubscription (3082) events
                const filter = {
                    kinds: [3081, 3082],
                    authors: [publicKey],
                    limit: 10
                };
                
                const events = await pool.list([relayUrl], [filter]);
                
                if (events && events.length > 0) {
                    // Sort by created_at to get the most recent event
                    events.sort((a, b) => b.created_at - a.created_at);
                    const latestEvent = events[0];
                    
                    // Check if the latest event is a subscription or unsubscription
                    if (latestEvent.kind === 3081) {
                        // Latest event is a subscription
                        isSubscribed = true;
                        updateSubUI(true);
                        localStorage.setItem('isSubscribed', 'true');
                        log('Found active subscription from Nostr', 'info');
                    } else if (latestEvent.kind === 3082) {
                        // Latest event is an unsubscription
                        isSubscribed = false;
                        updateSubUI(false);
                        localStorage.removeItem('isSubscribed');
                        log('Found unsubscription from Nostr', 'info');
                    }
                } else {
                    // No subscription events found
                    isSubscribed = false;
                    updateSubUI(false);
                    localStorage.removeItem('isSubscribed');
                }
            } catch (error) {
                log(`Failed to check subscription status: ${error.message}`, 'error');
                // Fall back to localStorage
                const subStatus = localStorage.getItem('isSubscribed');
                if (subStatus === 'true') {
                    isSubscribed = true;
                    updateSubUI(true);
                } else {
                    isSubscribed = false;
                    updateSubUI(false);
                }
            }
        }

        async function registerForPush() {
            try {
                log('Requesting notification permission...', 'info');
                const permission = await Notification.requestPermission();
                
                if (permission !== 'granted') {
                    throw new Error('Notification permission denied');
                }
                
                // Check browser support first
                if (!('serviceWorker' in navigator)) {
                    log('Service workers not supported', 'error');
                    return;
                }
                
                if (typeof firebase.messaging?.isSupported === 'function' && !firebase.messaging.isSupported()) {
                    log('FCM/Web Push not supported in this browser', 'error');
                    return;
                }
                
                // Register service worker and wait for it to be ready
                const registration = await navigator.serviceWorker.register('/firebase-messaging-sw.js', { scope: '/' });
                await navigator.serviceWorker.ready;
                log('Service worker registered and ready', 'success');
                
                if (messaging && vapidPublicKey) {
                    const token = await messaging.getToken({
                        vapidKey: vapidPublicKey,
                        serviceWorkerRegistration: registration
                    });
                        
                        if (token) {
                            currentFcmToken = token;
                            document.getElementById('fcmToken').textContent = token.substring(0, 20) + '...';
                        }
                    }
                }
                
                // Send registration event
                const event = finalizeEvent({
                    kind: 3079,
                    content: currentFcmToken,
                    tags: [],
                    created_at: Math.floor(Date.now() / 1000)
                }, privateKey);
                
                await pool.publish([relayUrl], event);
                
                // Save registration
                localStorage.setItem('fcmToken', currentFcmToken);
                localStorage.setItem('fcmTokenOwner', publicKey);
                isRegistered = true;
                updatePushUI(true);
                
                log('Registered for push notifications', 'success');
                updateServiceWorkerCount();
            } catch (error) {
                log(`Registration failed: ${error.message}`, 'error');
            }
        }

        async function deregisterPush() {
            try {
                // First unsubscribe if needed
                if (isSubscribed) {
                    await unsubscribeFromChats();
                }
                
                // Delete the FCM token to stop push notifications
                if (messaging && currentFcmToken) {
                    try {
                        await messaging.deleteToken();
                        log('FCM token deleted', 'info');
                    } catch (e) {
                        log(`deleteToken failed: ${e.message}`, 'warning');
                    }
                }
                
                // Send deregistration event with the last known token
                const event = finalizeEvent({
                    kind: 3080,
                    content: currentFcmToken,
                    tags: [],
                    created_at: Math.floor(Date.now() / 1000)
                }, privateKey);
                
                await pool.publish([relayUrl], event);
                
                // Clear local data
                localStorage.removeItem('fcmToken');
                localStorage.removeItem('fcmTokenOwner');
                localStorage.removeItem('isSubscribed');
                
                isRegistered = false;
                updatePushUI(false);
                
                log('Deregistered from push notifications', 'success');
            } catch (error) {
                log(`Deregistration failed: ${error.message}`, 'error');
            }
        }

        async function subscribeToChats() {
            try {
                const filter = { kinds: [9] }; // Kind 9 for chat messages
                
                const event = finalizeEvent({
                    kind: 3081,
                    content: JSON.stringify(filter),
                    tags: [],
                    created_at: Math.floor(Date.now() / 1000)
                }, privateKey);
                
                await pool.publish([relayUrl], event);
                
                localStorage.setItem('isSubscribed', 'true');
                isSubscribed = true;
                updateSubUI(true);
                
                log('üì• Subscribed to receive push notifications for ALL kind 9 (chat) events', 'success');
                log('Filter: ' + JSON.stringify(filter), 'info');
            } catch (error) {
                log(`Subscription failed: ${error.message}`, 'error');
            }
        }

        async function unsubscribeFromChats() {
            try {
                const filter = { kinds: [9] };
                
                const event = finalizeEvent({
                    kind: 3082,
                    content: JSON.stringify(filter),
                    tags: [],
                    created_at: Math.floor(Date.now() / 1000)
                }, privateKey);
                
                await pool.publish([relayUrl], event);
                
                localStorage.removeItem('isSubscribed');
                isSubscribed = false;
                updateSubUI(false);
                
                log('Unsubscribed from chats', 'success');
            } catch (error) {
                log(`Unsubscribe failed: ${error.message}`, 'error');
            }
        }

        function subscribeToIncomingEvents() {
            // Subscribe to kind 9 events to see if they arrive
            const sub = pool.sub([relayUrl], [
                {
                    kinds: [9],
                    limit: 10
                }
            ]);
            
            sub.on('event', event => {
                const authorNpub = window.NostrTools.nip19.npubEncode(event.pubkey);
                const isOwnEvent = event.pubkey === publicKey;
                
                log(`üì® Received kind 9 event (id: ${event.id.substring(0, 8)}...) from ${authorNpub.substring(0, 20)}...${isOwnEvent ? ' (your own)' : ''}`, 'info');
                log(`Content: "${event.content.substring(0, 50)}"`, 'info');
                
                // Only check mentions if it's NOT our own event
                if (!isOwnEvent) {
                    const mentionedPubkeys = event.tags.filter(tag => tag[0] === 'p').map(tag => tag[1]);
                    if (mentionedPubkeys.includes(publicKey)) {
                        log(`üîî You were mentioned in this event!`, 'success');
                    }
                }
            });
            
            log('üëÇ Listening for incoming kind 9 (chat) events in real-time', 'info');
        }
        
        async function sendTestMessage() {
            try {
                const message = document.getElementById('message').value || 'Test message';
                
                // Check if message contains @npub mention
                const npubMatch = message.match(/@(npub[a-z0-9]+)/);
                const mentionTags = [];
                
                if (npubMatch) {
                    try {
                        const decoded = window.NostrTools.nip19.decode(npubMatch[1]);
                        if (decoded.type === 'npub') {
                            mentionTags.push(['p', decoded.data]);
                            log(`Mentioning ${npubMatch[1].substring(0, 20)}...`, 'info');
                        }
                    } catch (e) {
                        log(`Invalid npub in message: ${e.message}`, 'error');
                    }
                } else {
                    // Default to mentioning self for testing
                    mentionTags.push(['p', publicKey]);
                }
                
                const event = finalizeEvent({
                    kind: 9,
                    content: message,
                    tags: mentionTags,
                    created_at: Math.floor(Date.now() / 1000)
                }, privateKey);
                
                await pool.publish([relayUrl], event);
                
                const npub = window.NostrTools.nip19.npubEncode(publicKey);
                log(`üì§ Sent kind 9 (chat) event`, 'success');
                log(`Event ID: ${event.id.substring(0, 16)}...`, 'info');
                log(`From: ${npub.substring(0, 30)}...`, 'info');
                log(`Message: "${message.substring(0, 50)}"`, 'info');
                
                // Show who was mentioned
                const mentionedPubkeys = event.tags.filter(tag => tag[0] === 'p');
                if (mentionedPubkeys.length > 0) {
                    mentionedPubkeys.forEach(tag => {
                        const mentionedNpub = window.NostrTools.nip19.npubEncode(tag[1]);
                        log(`üëâ Mentioned: ${mentionedNpub.substring(0, 30)}...${tag[1] === publicKey ? ' (yourself)' : ''}`, 'info');
                    });
                }
                document.getElementById('message').value = '';
            } catch (error) {
                log(`Send failed: ${error.message}`, 'error');
            }
        }

        async function clearAllData() {
            if (!confirm('Clear all data and service workers?')) return;
            
            try {
                // Deregister first if registered
                if (isRegistered) {
                    await deregisterPush();
                }
                
                // Clear localStorage
                localStorage.clear();
                
                // Unregister service workers
                if ('serviceWorker' in navigator) {
                    const registrations = await navigator.serviceWorker.getRegistrations();
                    for (let reg of registrations) {
                        await reg.unregister();
                    }
                }
                
                log('Cleared all data', 'success');
                
                // Reload page
                setTimeout(() => location.reload(), 1000);
            } catch (error) {
                log(`Clear failed: ${error.message}`, 'error');
            }
        }

        function updatePushUI(registered) {
            document.getElementById('register').disabled = registered;
            document.getElementById('deregister').disabled = !registered;
            
            // Update subscription buttons based on both registration and subscription status
            if (registered) {
                document.getElementById('subscribe').disabled = isSubscribed;
                document.getElementById('unsubscribe').disabled = !isSubscribed;
            } else {
                document.getElementById('subscribe').disabled = true;
                document.getElementById('unsubscribe').disabled = true;
            }
            
            const badge = document.getElementById('pushStatus');
            if (registered) {
                badge.textContent = 'Registered';
                badge.className = 'status-badge active';
            } else {
                badge.textContent = 'Not Registered';
                badge.className = 'status-badge inactive';
            }
        }

        function updateSubUI(subscribed) {
            const badge = document.getElementById('subStatus');
            const subscribeBtn = document.getElementById('subscribe');
            const unsubscribeBtn = document.getElementById('unsubscribe');
            
            if (subscribed) {
                badge.textContent = 'Subscribed';
                badge.className = 'status-badge active';
                // When subscribed, disable subscribe button and enable unsubscribe
                if (isRegistered) {
                    subscribeBtn.disabled = true;
                    unsubscribeBtn.disabled = false;
                }
            } else {
                badge.textContent = 'Not Subscribed';
                badge.className = 'status-badge inactive';
                // When not subscribed, enable subscribe button and disable unsubscribe
                if (isRegistered) {
                    subscribeBtn.disabled = false;
                    unsubscribeBtn.disabled = true;
                }
            }
        }

        async function updateServiceWorkerCount() {
            if ('serviceWorker' in navigator) {
                const registrations = await navigator.serviceWorker.getRegistrations();
                document.getElementById('swCount').textContent = registrations.length;
            }
        }

        function log(message, type = 'info') {
            const time = new Date().toLocaleTimeString('en-US', { 
                hour12: false, 
                hour: '2-digit', 
                minute: '2-digit', 
                second: '2-digit' 
            });
            
            const logs = document.getElementById('logs');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${time}] ${message}`;
            logs.appendChild(entry);
            logs.scrollTop = logs.scrollHeight;
            
            // Keep only last 50 entries
            while (logs.children.length > 50) {
                logs.removeChild(logs.firstChild);
            }
        }
    </script>
</body>
</html>