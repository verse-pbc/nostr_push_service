<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nostr Push Dev Tool</title>
    
    <!-- PWA manifest and iOS support -->
    <link rel="manifest" href="/manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Plur Push">
    <link rel="apple-touch-icon" href="/icon-192x192.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
            background: #2a2a2a;
            color: #e0e0e0;
            padding: 10px;
            font-size: 13px;
        }
        
        .container {
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 12px;
            max-width: 800px;
            margin: 0 auto;
        }
        
        h1 {
            color: #fff;
            font-size: 18px;
            margin-bottom: 10px;
            font-weight: normal;
        }
        
        .info-bar {
            background: #2a3f5f;
            padding: 8px 10px;
            margin-bottom: 12px;
            border-radius: 3px;
            font-size: 12px;
            color: #aaa;
            line-height: 1.4;
        }
        
        .info-bar code {
            color: #4fc3f7;
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 12px;
        }
        
        .section {
            background: #222;
            border: 1px solid #333;
            padding: 10px;
            border-radius: 3px;
        }
        
        .section h2 {
            font-size: 14px;
            margin-bottom: 8px;
            color: #4fc3f7;
            font-weight: normal;
        }
        
        button {
            background: #4fc3f7;
            color: #000;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 6px;
            margin-bottom: 8px;
            font-family: inherit;
            min-height: 36px;
            transition: background 0.2s;
        }
        
        button:hover:not(:disabled) {
            background: #29b6f6;
        }
        
        button:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }
        
        button.danger {
            background: #e91e63;
            color: white;
        }
        
        button.danger:hover {
            background: #c2185b;
        }
        
        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin-left: 6px;
            font-weight: 500;
        }
        
        .status-badge.active {
            background: #4caf50;
            color: white;
        }
        
        .status-badge.inactive {
            background: #666;
            color: #ccc;
        }
        
        .status-badge.warning {
            background: #ff9800;
            color: white;
        }
        
        .status-badge.error {
            background: #f44336;
            color: white;
        }
        
        textarea {
            width: 100%;
            padding: 8px;
            background: #333;
            border: 1px solid #555;
            color: #e0e0e0;
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
            resize: vertical;
            min-height: 50px;
        }
        
        .logs {
            background: #000;
            color: #0f0;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
            height: 150px;
            overflow-y: auto;
            border: 1px solid #333;
            -webkit-overflow-scrolling: touch;
        }
        
        .log-entry {
            margin-bottom: 3px;
            line-height: 1.3;
        }
        
        .log-entry.error {
            color: #f44336;
        }
        
        .log-entry.warning {
            color: #ff9800;
        }
        
        .log-entry.info {
            color: #03a9f4;
        }
        
        .log-entry.success {
            color: #4caf50;
        }
        
        .pubkey {
            font-family: monospace;
            font-size: 11px;
            color: #888;
            word-break: break-all;
            margin: 6px 0;
            line-height: 1.4;
        }
        
        .hidden {
            display: none;
        }
        
        .debug-info {
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 10px;
            margin-top: 10px;
            border-radius: 4px;
            font-size: 11px;
            font-family: monospace;
            color: #888;
        }
        
        .debug-info div {
            margin: 4px 0;
            line-height: 1.4;
        }
        
        .quick-start {
            background: #2a3f5f;
            border-left: 3px solid #4fc3f7;
            padding: 10px;
            margin-bottom: 12px;
            font-size: 12px;
            line-height: 1.5;
        }
        
        .quick-start ol {
            margin: 6px 0 0 24px;
            padding: 0;
        }
        
        /* Mobile responsive styles */
        @media (max-width: 600px) {
            body {
                padding: 8px;
                font-size: 14px;
            }
            
            .container {
                padding: 10px;
            }
            
            h1 {
                font-size: 20px;
                margin-bottom: 12px;
            }
            
            .info-bar {
                font-size: 13px;
                padding: 10px;
            }
            
            .grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .section {
                padding: 12px;
            }
            
            .section h2 {
                font-size: 15px;
                margin-bottom: 10px;
            }
            
            button {
                padding: 10px 14px;
                font-size: 13px;
                min-height: 44px;
                width: 100%;
                margin-right: 0;
                margin-bottom: 10px;
            }
            
            .status-badge {
                display: block;
                margin: 10px 0;
                text-align: center;
                padding: 6px 10px;
                font-size: 12px;
            }
            
            textarea {
                font-size: 13px;
                padding: 10px;
                min-height: 60px;
            }
            
            .logs {
                height: 200px;
                font-size: 12px;
                padding: 12px;
            }
            
            .log-entry {
                margin-bottom: 4px;
                line-height: 1.4;
            }
            
            .pubkey {
                font-size: 12px;
                margin: 8px 0;
            }
            
            .debug-info {
                padding: 12px;
                font-size: 12px;
            }
            
            .debug-info div {
                margin: 6px 0;
            }
            
            .quick-start {
                font-size: 13px;
                padding: 12px;
            }
            
            .quick-start ol {
                margin-left: 20px;
            }
        }
        
        /* Ensure touch targets are at least 44x44 pixels */
        @media (pointer: coarse) {
            button {
                min-height: 44px;
                min-width: 44px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîî Nostr Push Notification Dev Tool</h1>
        
        <div class="info-bar">
            <strong>iOS Setup:</strong> 
            Add to Home Screen from Safari ‚Üí Open PWA ‚Üí Register for push ‚Ä¢ HTTPS required ‚Ä¢ Push only works in PWA mode
        </div>

        <div class="quick-start">
            <strong>Quick Test:</strong>
            <ol>
                <li>Register for Push Notifications</li>
                <li>Subscribe to Chats</li>
                <li>Open another browser and Send to Relay</li>
                <li>You should receive a push notification!</li>
            </ol>
        </div>

        <div class="grid">
            <div class="section">
                <h2>üîë Identity</h2>
                <div class="pubkey" style="word-break: break-all;">npub: <span id="pubkey" style="font-size: 0.8em;">generating...</span></div>
                <div class="pubkey" style="word-break: break-all;">nsec: <span id="privkey" style="font-size: 0.8em;">generating...</span></div>
            </div>
            
            <div class="section">
                <h2>üì± Push Notifications</h2>
                <button id="register" onclick="registerForPush()">Register for Push (kind 3079)</button>
                <button id="deregister" onclick="deregisterPush()" disabled>Deregister (kind 3080)</button>
                <span id="pushStatus" class="status-badge inactive">Not Registered</span>
            </div>
        </div>

        <div class="grid">
            <div class="section">
                <h2>üí¨ Chat Subscriptions</h2>
                <button id="subscribe" onclick="subscribeToChats()" disabled>Subscribe to Chats (kind 3081)</button>
                <button id="unsubscribe" onclick="unsubscribeFromChats()" disabled>Unsubscribe (kind 3082)</button>
                <span id="subStatus" class="status-badge inactive">Not Subscribed</span>
            </div>
            
            <div class="section">
                <h2>‚úâÔ∏è Send Test</h2>
                <textarea id="message" placeholder="Test message..."></textarea>
                <button onclick="sendTestMessage()">Send to Relay (kind 9)</button>
            </div>
        </div>

        <div class="section">
            <h2>üìã Activity Log</h2>
            <div class="logs" id="logs"></div>
        </div>

        <div class="debug-info">
            <div><strong>Service Workers:</strong> <span id="swCount">0</span> active</div>
            <div><strong>FCM Token:</strong> <span id="fcmToken">none</span></div>
            <div><strong>Relay:</strong> <span id="relayStatus">disconnected</span></div>
            <button class="danger" onclick="clearAllData()">Clear All Data & Service Workers</button>
        </div>
    </div>

    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-messaging-compat.js"></script>
    
    <!-- Nostr Tools -->
    <!-- Using CDN version for demo -->
    <script src="https://unpkg.com/nostr-tools@2.10.1/lib/nostr.bundle.js"></script>

    <script>
        // Global variables
        let pool = null;
        let privateKey = null;
        let publicKey = null;
        let messaging = null;
        let currentFcmToken = null;
        let isRegistered = false;
        let isSubscribed = false;
        let vapidPublicKey = null;
        const relayUrl = 'wss://communities.nos.social';
        
        // Nostr tools functions (will be initialized after library loads)
        let SimplePool, getPublicKey, generateSecretKey, finalizeEvent, getEventHash;

        // Auto-initialize on load
        // Function to wait for NostrTools to load
        async function waitForNostrTools(maxRetries = 10) {
            for (let i = 0; i < maxRetries; i++) {
                if (window.NostrTools) {
                    return true;
                }
                log(`Waiting for NostrTools to load... (${i + 1}/${maxRetries})`, 'info');
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            return false;
        }

        window.addEventListener('load', async () => {
            log('Initializing...', 'info');
            
            // Check for push notification support
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            const isStandalone = window.navigator.standalone || window.matchMedia('(display-mode: standalone)').matches;
            
            if (!('Notification' in window)) {
                log('‚ö†Ô∏è Push notifications not supported', 'warning');
                document.getElementById('register').disabled = true;
                document.getElementById('pushStatus').textContent = 'Not Supported';
                document.getElementById('pushStatus').className = 'status-badge error';
            } else if (isIOS && !isStandalone) {
                log('üì± iOS Safari: Add to Home Screen for push notifications', 'info');
                log('Tap Share ‚Üí Add to Home Screen, then open from home screen', 'info');
                document.getElementById('pushStatus').textContent = 'Add to Home Screen';
                document.getElementById('pushStatus').className = 'status-badge warning';
            }
            
            // Wait for NostrTools to load (important for PWA mode)
            const nostrLoaded = await waitForNostrTools();
            if (!nostrLoaded) {
                log('Failed to load NostrTools after retries', 'error');
                document.getElementById('pubkey').textContent = 'Failed to load NostrTools';
                document.getElementById('privkey').textContent = 'Try refreshing the page';
                return;
            }
            
            // Initialize nostr-tools functions
            if (window.NostrTools) {
                const tools = window.NostrTools;
                SimplePool = tools.SimplePool;
                getPublicKey = tools.getPublicKey;
                generateSecretKey = tools.generateSecretKey;
                finalizeEvent = tools.finishEvent || tools.finalizeEvent;
                getEventHash = tools.getEventHash;
                pool = new SimplePool();
            } else {
                log('NostrTools not loaded!', 'error');
                return;
            }
            
            // Generate or restore keys
            generateKeys();
            
            // Initialize Firebase
            await initializeFirebase();
            
            // Connect to relay
            await connectToRelay();
            
            // Check registration status
            checkRegistrationStatus();
            
            // Check subscription status (for buttons state)
            await checkSubscriptionStatus();
            
            // Subscribe to incoming events for debugging
            subscribeToIncomingEvents();
            
            // Count service workers
            updateServiceWorkerCount();
        });

        function generateKeys() {
            try {
                // Debug: Check what's available
                console.log('NostrTools:', window.NostrTools);
                if (!window.NostrTools) {
                    throw new Error('NostrTools not loaded');
                }
                console.log('Available functions:', Object.keys(window.NostrTools).sort());
                
                // Check for existing key
                const storedKey = localStorage.getItem('privateKey');
            
            if (storedKey) {
                // Stored as hex string
                privateKey = storedKey;
                // Get public key - both are hex strings
                publicKey = window.NostrTools.getPublicKey(privateKey);
                // npubEncode expects hex string directly!
                const npub = window.NostrTools.nip19.npubEncode(publicKey);
                log(`Restored existing keypair: ${npub.substring(0, 30)}...`, 'info');
            } else {
                // Generate new key - generateSecretKey returns Uint8Array, convert to hex
                const secretKeyBytes = window.NostrTools.generateSecretKey();
                // Convert bytes to hex string
                const bytesToHex = (bytes) => Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
                privateKey = bytesToHex(secretKeyBytes);
                localStorage.setItem('privateKey', privateKey);
                // Get public key - both are hex strings
                publicKey = window.NostrTools.getPublicKey(privateKey);
                // npubEncode expects hex string directly!
                const npub = window.NostrTools.nip19.npubEncode(publicKey);
                log(`Generated new keypair: ${npub.substring(0, 30)}...`, 'success');
            }
            
            // Convert to bech32 formats for display
            // npubEncode expects hex string, nsecEncode expects bytes
            const hexToBytes = (hex) => new Uint8Array(hex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
            const npub = window.NostrTools.nip19.npubEncode(publicKey);  // hex string
            const nsec = window.NostrTools.nip19.nsecEncode(hexToBytes(privateKey));  // bytes
            
            // Update UI with full keys for testing
            document.getElementById('pubkey').textContent = npub;
            document.getElementById('privkey').textContent = nsec;
            } catch (error) {
                console.error('Key generation error:', error);
                log(`Key generation failed: ${error.message}`, 'error');
                document.getElementById('pubkey').textContent = 'Error: ' + error.message;
                document.getElementById('privkey').textContent = 'Error: ' + error.message;
            }
        }

        async function initializeFirebase() {
            try {
                const response = await fetch('/config/fcm.json', { cache: 'no-store' });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    log(`FCM config error: ${response.status} - ${errorText.substring(0, 100)}`, 'error');
                    return false;
                }
                
                const responseText = await response.text();
                
                let config;
                try {
                    config = JSON.parse(responseText);
                } catch (e) {
                    log(`Invalid FCM config JSON: ${e.message}`, 'error');
                    log(`Response: ${responseText.substring(0, 200)}`, 'error');
                    return false;
                }
                
                if (!config.apiKey || config.apiKey === "") {
                    log('Firebase not configured. Push disabled.', 'warning');
                    document.getElementById('register').disabled = true;
                    return false;
                }
                
                firebase.initializeApp(config);
                
                // Check if we're in a secure context (required for service workers and notifications)
                if (!window.isSecureContext) {
                    log('‚ö†Ô∏è Not in secure context!', 'error');
                    log(`Current URL: ${window.location.href}`, 'info');
                    log('Push notifications require HTTPS or localhost', 'error');
                    
                    if (window.location.protocol === 'http:' && window.location.hostname !== 'localhost') {
                        log('Solutions:', 'info');
                        log('1. Use the HTTPS ngrok URL', 'info');
                        log('2. Or access via http://localhost:8000', 'info');
                    }
                    
                    // Still try to initialize but it likely won't work
                    messaging = null;
                    document.getElementById('register').disabled = true;
                    return false;
                }
                
                // Initialize Firebase Messaging if service worker is available
                if ('serviceWorker' in navigator) {
                    try {
                        messaging = firebase.messaging();
                        log('Firebase Messaging initialized', 'success');
                    } catch (e) {
                        log(`Firebase Messaging init error: ${e.message}`, 'error');
                        messaging = null;
                        return false;
                    }
                } else {
                    // Service worker not available - might be a timing issue in PWA
                    log('Service Worker API not immediately available', 'warning');
                    
                    // If we're in a PWA, wait a bit for it to become available
                    if (window.navigator.standalone) {
                        log('PWA detected, waiting for Service Worker...', 'info');
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        
                        if ('serviceWorker' in navigator) {
                            try {
                                messaging = firebase.messaging();
                                log('Firebase Messaging initialized after wait', 'success');
                            } catch (e) {
                                log(`Firebase Messaging error: ${e.message}`, 'error');
                                messaging = null;
                                return false;
                            }
                        } else {
                            log('Service Worker still not available', 'error');
                            log('This should not happen in HTTPS context', 'error');
                            messaging = null;
                            return false;
                        }
                    } else {
                        log('Service Worker not available', 'error');
                        messaging = null;
                        return false;
                    }
                }
                
                vapidPublicKey = config.vapidPublicKey;
                
                // Handle foreground messages
                messaging.onMessage((payload) => {
                    log(`Message received: ${payload.data?.title || 'Notification'}`, 'success');
                    
                    // Show notification even in foreground
                    if ('Notification' in window && Notification.permission === 'granted') {
                        const notification = new Notification(
                            payload.data?.title || 'New Message',
                            {
                                body: payload.data?.body || '',
                                icon: '/favicon.ico'
                            }
                        );
                        
                        notification.onclick = () => {
                            window.focus();
                            notification.close();
                        };
                    }
                });
                
                log('Firebase initialized', 'success');
                return true;
            } catch (error) {
                log(`Firebase init failed: ${error.message}`, 'error');
                return false;
            }
        }

        async function connectToRelay() {
            try {
                if (!pool) {
                    log('Pool not initialized', 'error');
                    return;
                }
                await pool.ensureRelay(relayUrl);
                
                document.getElementById('relayStatus').textContent = relayUrl;
                log(`Connected to relay: ${relayUrl}`, 'success');
            } catch (error) {
                log(`Relay connection failed: ${error.message}`, 'error');
                document.getElementById('relayStatus').textContent = 'error';
            }
        }

        async function checkRegistrationStatus() {
            // First check registration status from Nostr
            await checkRegistrationFromNostr();
            
            // Then check subscription status from Nostr
            await checkSubscriptionFromNostr();
        }
        
        async function checkRegistrationFromNostr() {
            try {
                // Query for both registration (3079) and deregistration (3080) events
                const filter = {
                    kinds: [3079, 3080],
                    authors: [publicKey],
                    limit: 10
                };
                
                const events = await pool.querySync([relayUrl], filter);
                
                if (events && events.length > 0) {
                    // Sort by created_at to get the most recent event
                    events.sort((a, b) => b.created_at - a.created_at);
                    const latestEvent = events[0];
                    
                    // Check if the latest event is a registration or deregistration
                    if (latestEvent.kind === 3079) {
                        // Latest event is a registration
                        currentFcmToken = latestEvent.content || 'registered';
                        isRegistered = true;
                        updatePushUI(true);
                        localStorage.setItem('fcmToken', currentFcmToken);
                        localStorage.setItem('fcmTokenOwner', publicKey);
                        document.getElementById('fcmToken').textContent = currentFcmToken.substring(0, 20) + '...';
                        log('Found active registration from Nostr', 'info');
                    } else if (latestEvent.kind === 3080) {
                        // Latest event is a deregistration
                        currentFcmToken = null;
                        isRegistered = false;
                        updatePushUI(false);
                        localStorage.removeItem('fcmToken');
                        localStorage.removeItem('fcmTokenOwner');
                        document.getElementById('fcmToken').textContent = '';
                        log('Found deregistration from Nostr', 'info');
                    }
                } else {
                    // No registration events found - check localStorage as fallback
                    const savedToken = localStorage.getItem('fcmToken');
                    const savedOwner = localStorage.getItem('fcmTokenOwner');
                    
                    if (savedToken && savedOwner === publicKey) {
                        currentFcmToken = savedToken;
                        isRegistered = true;
                        updatePushUI(true);
                        document.getElementById('fcmToken').textContent = savedToken.substring(0, 20) + '...';
                    } else {
                        isRegistered = false;
                        updatePushUI(false);
                    }
                }
            } catch (error) {
                log(`Failed to check registration status: ${error.message}`, 'error');
                // Fall back to localStorage
                const savedToken = localStorage.getItem('fcmToken');
                const savedOwner = localStorage.getItem('fcmTokenOwner');
                
                if (savedToken && savedOwner === publicKey) {
                    currentFcmToken = savedToken;
                    isRegistered = true;
                    updatePushUI(true);
                    document.getElementById('fcmToken').textContent = savedToken.substring(0, 20) + '...';
                } else {
                    isRegistered = false;
                    updatePushUI(false);
                }
            }
        }
        
        async function checkSubscriptionFromNostr() {
            try {
                // Query for both subscription (3081) and unsubscription (3082) events
                const filter = {
                    kinds: [3081, 3082],
                    authors: [publicKey],
                    limit: 10
                };
                
                const events = await pool.querySync([relayUrl], filter);
                
                if (events && events.length > 0) {
                    // Sort by created_at to get the most recent event
                    events.sort((a, b) => b.created_at - a.created_at);
                    const latestEvent = events[0];
                    
                    // Check if the latest event is a subscription or unsubscription
                    if (latestEvent.kind === 3081) {
                        // Latest event is a subscription
                        isSubscribed = true;
                        updateSubUI(true);
                        localStorage.setItem('isSubscribed', 'true');
                        log('Found active subscription from Nostr', 'info');
                    } else if (latestEvent.kind === 3082) {
                        // Latest event is an unsubscription
                        isSubscribed = false;
                        updateSubUI(false);
                        localStorage.removeItem('isSubscribed');
                        log('Found unsubscription from Nostr', 'info');
                    }
                } else {
                    // No subscription events found
                    isSubscribed = false;
                    updateSubUI(false);
                    localStorage.removeItem('isSubscribed');
                }
            } catch (error) {
                log(`Failed to check subscription status: ${error.message}`, 'error');
                // Fall back to localStorage
                const subStatus = localStorage.getItem('isSubscribed');
                if (subStatus === 'true') {
                    isSubscribed = true;
                    updateSubUI(true);
                } else {
                    isSubscribed = false;
                    updateSubUI(false);
                }
            }
        }

        async function handleTokenRegistration(token) {
            try {
                currentFcmToken = token;
                document.getElementById('fcmToken').textContent = token.substring(0, 20) + '...';
                
                // Send registration event
                const event = finalizeEvent({
                    kind: 3079,
                    content: currentFcmToken,
                    tags: [],
                    created_at: Math.floor(Date.now() / 1000)
                }, privateKey);

                await pool.publish([relayUrl], event);
                
                // Save registration
                localStorage.setItem('fcmToken', currentFcmToken);
                localStorage.setItem('fcmTokenOwner', publicKey);
                isRegistered = true;
                updatePushUI(true);
                
                log('‚úÖ Registration complete!', 'success');
                updateRegistrationStatus();
            } catch (error) {
                log(`Registration error: ${error.message}`, 'error');
                throw error;
            }
        }
        
        async function registerForPush() {
            try {
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                const isStandalone = window.navigator.standalone || window.matchMedia('(display-mode: standalone)').matches;
                
                // Debug: Log environment details
                log('=== Environment Check ===', 'info');
                log(`Platform: ${isIOS ? 'iOS' : 'non-iOS'}`, 'info');
                log(`Mode: ${isStandalone ? 'PWA/Standalone' : 'Browser'}`, 'info');
                log(`URL: ${window.location.href}`, 'info');
                log(`Secure Context: ${window.isSecureContext ? '‚úÖ YES' : '‚ùå NO'}`, 'info');
                
                // Check API availability
                log('=== API Availability ===', 'info');
                log(`Notification: ${'Notification' in window ? '‚úÖ YES' : '‚ùå NO'}`, 'info');
                log(`PushManager: ${'PushManager' in window ? '‚úÖ YES' : '‚ùå NO'}`, 'info');
                log(`ServiceWorker: ${'serviceWorker' in navigator ? '‚úÖ YES' : '‚ùå NO'}`, 'info');
                
                // Check if we're in secure context
                if (!window.isSecureContext) {
                    log('‚ùå Not in secure context - APIs won\'t be available!', 'error');
                    log('Use HTTPS URL or http://localhost', 'error');
                    return;
                }
                
                // Check iframe (ngrok warning)
                if (window !== window.top) {
                    log('‚ö†Ô∏è Page in iframe - might be ngrok warning', 'warning');
                    log('Click "Visit Site" if you see ngrok page', 'info');
                }
                
                // Check for Notification API support
                if (!('Notification' in window)) {
                    log('Notification API not found', 'error');
                    
                    // Check if iOS
                    if (isIOS) {
                        if (!isStandalone) {
                            log('üì± iOS detected - Push requires PWA mode!', 'error');
                            log('To enable push notifications:', 'info');
                            log('1. Tap Share button (box with arrow)', 'info');
                            log('2. Select "Add to Home Screen"', 'info');
                            log('3. Open app from home screen', 'info');
                            log('4. Register for push from the PWA', 'info');
                        } else {
                            // In PWA but still no API - probably HTTP
                            log('‚ö†Ô∏è HTTPS required for notifications!', 'error');
                            log('Use HTTPS URL or http://localhost', 'error');
                        }
                    } else if (window.location.protocol === 'http:' && window.location.hostname !== 'localhost') {
                        // Non-iOS, insecure context
                        log('‚ö†Ô∏è HTTPS required for notifications!', 'error');
                        log(`You're using: ${window.location.protocol}//${window.location.hostname}`, 'info');
                        log('Options:', 'info');
                        log('1. Use http://localhost:8000 instead', 'info');
                        log('2. Set up HTTPS for this domain', 'info');
                    } else {
                        // Non-iOS, other issue
                        log('Push notifications not supported in this browser', 'info');
                        log('Try Chrome, Firefox, or Safari 16.4+', 'info');
                    }
                    return;
                }
                
                // Additional check for push manager
                if (!('PushManager' in window)) {
                    log('PushManager not available', 'error');
                    log('Web Push might not be supported in this browser', 'info');
                    return;
                }
                
                // iOS-specific push notification requirements
                if (isIOS) {
                    log('=== iOS Push Requirements ===', 'info');
                    
                    if (!isStandalone) {
                        // Safari browser - push NOT supported on iOS
                        log('‚ùå iOS Safari browser - Push not available here', 'error');
                        log('iOS requires PWA mode for push notifications:', 'info');
                        log('1. Tap Share button (box with arrow)', 'info');
                        log('2. Select "Add to Home Screen"', 'info');
                        log('3. Open app from home screen', 'info');
                        log('4. Register for push from the PWA', 'info');
                        return;
                    }
                    
                    // In PWA mode - push should work!
                    log('‚úÖ iOS PWA mode - Push supported!', 'success');
                    
                    // Double-check service worker availability
                    if (!('serviceWorker' in navigator)) {
                        log('‚ö†Ô∏è Service Worker not found in iOS PWA', 'error');
                        log('Ensure you\'re using HTTPS!', 'error');
                        log(`Current context secure: ${window.isSecureContext}`, 'info');
                        
                        // Wait and retry once
                        log('Waiting 2 seconds and retrying...', 'info');
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        
                        if (!('serviceWorker' in navigator)) {
                            log('‚ùå Service Worker still unavailable', 'error');
                            return;
                        }
                        log('‚úÖ Service Worker now available!', 'success');
                    }
                }
                
                // Check browser support - in PWA mode, serviceWorker might not be immediately available
                let serviceWorkerAvailable = 'serviceWorker' in navigator;
                
                // If in PWA mode and service worker not available, wait a bit
                if (!serviceWorkerAvailable && window.navigator.standalone) {
                    log('Waiting for service worker API...', 'info');
                    for (let i = 0; i < 10; i++) {
                        await new Promise(resolve => setTimeout(resolve, 500));
                        if ('serviceWorker' in navigator) {
                            serviceWorkerAvailable = true;
                            log('Service worker API now available', 'success');
                            break;
                        }
                    }
                }
                
                if (!serviceWorkerAvailable) {
                    log('Service workers not supported', 'error');
                    log('Try closing and reopening the app', 'info');
                    return;
                }
                
                if (typeof firebase.messaging?.isSupported === 'function' && !firebase.messaging.isSupported()) {
                    log('FCM/Web Push not supported in this browser', 'error');
                    return;
                }
                
                log('Requesting notification permission...', 'info');
                const permission = await Notification.requestPermission();
                
                if (permission !== 'granted') {
                    throw new Error('Notification permission denied');
                }
                
                // Register service worker and wait for it to be ready
                const registration = await navigator.serviceWorker.register('/firebase-messaging-sw.js', { scope: '/' });
                await navigator.serviceWorker.ready;
                log('Service worker registered and ready', 'success');
                
                if (messaging && vapidPublicKey) {
                    const token = await messaging.getToken({
                        vapidKey: vapidPublicKey,
                        serviceWorkerRegistration: registration
                    });
                    
                    if (token) {
                        currentFcmToken = token;
                        document.getElementById('fcmToken').textContent = token.substring(0, 20) + '...';
                    }
                }
                
                // Send registration event
                const event = finalizeEvent({
                    kind: 3079,
                    content: currentFcmToken,
                    tags: [],
                    created_at: Math.floor(Date.now() / 1000)
                }, privateKey);
                
                await pool.publish([relayUrl], event);
                
                // Save registration
                localStorage.setItem('fcmToken', currentFcmToken);
                localStorage.setItem('fcmTokenOwner', publicKey);
                isRegistered = true;
                updatePushUI(true);
                
                log('Registered for push notifications', 'success');
                updateServiceWorkerCount();
            } catch (error) {
                log(`Registration failed: ${error.message}`, 'error');
            }
        }

        async function deregisterPush() {
            try {
                // First unsubscribe if needed
                if (isSubscribed) {
                    await unsubscribeFromChats();
                }
                
                // Delete the FCM token to stop push notifications
                if (messaging && currentFcmToken) {
                    try {
                        await messaging.deleteToken();
                        log('FCM token deleted', 'info');
                    } catch (e) {
                        log(`deleteToken failed: ${e.message}`, 'warning');
                    }
                }
                
                // Send deregistration event with the last known token
                const event = finalizeEvent({
                    kind: 3080,
                    content: currentFcmToken,
                    tags: [],
                    created_at: Math.floor(Date.now() / 1000)
                }, privateKey);
                
                await pool.publish([relayUrl], event);
                
                // Clear local data
                localStorage.removeItem('fcmToken');
                localStorage.removeItem('fcmTokenOwner');
                localStorage.removeItem('isSubscribed');
                
                isRegistered = false;
                updatePushUI(false);
                
                log('Deregistered from push notifications', 'success');
            } catch (error) {
                log(`Deregistration failed: ${error.message}`, 'error');
            }
        }

        async function subscribeToChats() {
            try {
                const filter = { kinds: [9] }; // Kind 9 for chat messages
                
                const event = finalizeEvent({
                    kind: 3081,
                    content: JSON.stringify(filter),
                    tags: [],
                    created_at: Math.floor(Date.now() / 1000)
                }, privateKey);
                
                await pool.publish([relayUrl], event);
                
                log('üì• Subscribed to receive push notifications for ALL kind 9 (chat) events', 'success');
                log('Filter: ' + JSON.stringify(filter), 'info');
                
                // Check actual subscription status from relay
                setTimeout(() => checkSubscriptionStatus(), 1000);
            } catch (error) {
                log(`Subscription failed: ${error.message}`, 'error');
            }
        }

        async function unsubscribeFromChats() {
            try {
                const filter = { kinds: [9] };
                
                const event = finalizeEvent({
                    kind: 3082,
                    content: JSON.stringify(filter),
                    tags: [],
                    created_at: Math.floor(Date.now() / 1000)
                }, privateKey);
                
                await pool.publish([relayUrl], event);
                
                log('Unsubscribed from chats', 'success');
                
                // Check actual subscription status from relay
                setTimeout(() => checkSubscriptionStatus(), 1000);
            } catch (error) {
                log(`Unsubscribe failed: ${error.message}`, 'error');
            }
        }

        function subscribeToIncomingEvents() {
            // Subscribe to kind 9 events to see if they arrive
            const sub = pool.subscribeMany([relayUrl], [
                {
                    kinds: [9],
                    limit: 10
                }
            ], {
                onevent(event) {
                const authorNpub = window.NostrTools.nip19.npubEncode(event.pubkey);
                const isOwnEvent = event.pubkey === publicKey;
                
                log(`üì® Received kind 9 event (id: ${event.id.substring(0, 8)}...) from ${authorNpub.substring(0, 20)}...${isOwnEvent ? ' (your own)' : ''}`, 'info');
                log(`Content: "${event.content.substring(0, 50)}"`, 'info');
                
                // Only check mentions if it's NOT our own event
                if (!isOwnEvent) {
                    const mentionedPubkeys = event.tags.filter(tag => tag[0] === 'p').map(tag => tag[1]);
                    if (mentionedPubkeys.includes(publicKey)) {
                        log(`üîî You were mentioned in this event!`, 'success');
                    }
                }
                }
            });
            
            log('üëÇ Listening for incoming kind 9 (chat) events in real-time', 'info');
        }
        
        async function sendTestMessage() {
            try {
                const message = document.getElementById('message').value || 'Test message';
                
                // Check if message contains @npub mention
                const npubMatch = message.match(/@(npub[a-z0-9]+)/);
                const mentionTags = [];
                
                if (npubMatch) {
                    try {
                        const decoded = window.NostrTools.nip19.decode(npubMatch[1]);
                        if (decoded.type === 'npub') {
                            mentionTags.push(['p', decoded.data]);
                            log(`Mentioning ${npubMatch[1].substring(0, 20)}...`, 'info');
                        }
                    } catch (e) {
                        log(`Invalid npub in message: ${e.message}`, 'error');
                    }
                } else {
                    // Default to mentioning self for testing
                    mentionTags.push(['p', publicKey]);
                }
                
                const event = finalizeEvent({
                    kind: 9,
                    content: message,
                    tags: mentionTags,
                    created_at: Math.floor(Date.now() / 1000)
                }, privateKey);
                
                await pool.publish([relayUrl], event);
                
                const npub = window.NostrTools.nip19.npubEncode(publicKey);
                log(`üì§ Sent kind 9 (chat) event`, 'success');
                log(`Event ID: ${event.id.substring(0, 16)}...`, 'info');
                log(`From: ${npub.substring(0, 30)}...`, 'info');
                log(`Message: "${message.substring(0, 50)}"`, 'info');
                
                // Show who was mentioned
                const mentionedPubkeys = event.tags.filter(tag => tag[0] === 'p');
                if (mentionedPubkeys.length > 0) {
                    mentionedPubkeys.forEach(tag => {
                        const mentionedNpub = window.NostrTools.nip19.npubEncode(tag[1]);
                        log(`üëâ Mentioned: ${mentionedNpub.substring(0, 30)}...${tag[1] === publicKey ? ' (yourself)' : ''}`, 'info');
                    });
                }
                document.getElementById('message').value = '';
            } catch (error) {
                log(`Send failed: ${error.message}`, 'error');
            }
        }

        async function clearAllData() {
            if (!confirm('This will unsubscribe, deregister, and clear all data. Continue?')) return;
            
            try {
                log('Starting complete data cleanup...', 'info');
                
                // Step 1: Unsubscribe from chats if subscribed
                const subStatus = document.getElementById('subStatus').textContent;
                if (subStatus === 'Subscribed') {
                    log('Unsubscribing from chats (kind 3082)...', 'info');
                    await unsubscribeFromChats();
                    await new Promise(resolve => setTimeout(resolve, 500)); // Small delay
                }
                
                // Step 2: Deregister push notifications if registered
                if (isRegistered) {
                    log('Deregistering push notifications (kind 3080)...', 'info');
                    await deregisterPush();
                    await new Promise(resolve => setTimeout(resolve, 500)); // Small delay
                }
                
                // Step 3: Clear localStorage
                log('Clearing local storage...', 'info');
                localStorage.clear();
                
                // Step 4: Unregister service workers
                if ('serviceWorker' in navigator) {
                    log('Unregistering service workers...', 'info');
                    const registrations = await navigator.serviceWorker.getRegistrations();
                    for (let reg of registrations) {
                        await reg.unregister();
                        log(`Unregistered SW: ${reg.scope}`, 'info');
                    }
                }
                
                log('‚úÖ Complete cleanup successful!', 'success');
                log('Reloading page in 2 seconds...', 'info');
                
                // Reload page
                setTimeout(() => location.reload(), 2000);
            } catch (error) {
                log(`‚ùå Cleanup failed: ${error.message}`, 'error');
            }
        }

        function updatePushUI(registered) {
            document.getElementById('register').disabled = registered;
            document.getElementById('deregister').disabled = !registered;
            
            // Update subscription buttons based on both registration and subscription status
            if (registered) {
                document.getElementById('subscribe').disabled = isSubscribed;
                document.getElementById('unsubscribe').disabled = !isSubscribed;
            } else {
                document.getElementById('subscribe').disabled = true;
                document.getElementById('unsubscribe').disabled = true;
            }
            
            const badge = document.getElementById('pushStatus');
            if (registered) {
                badge.textContent = 'Registered';
                badge.className = 'status-badge active';
            } else {
                badge.textContent = 'Not Registered';
                badge.className = 'status-badge inactive';
            }
        }

        async function checkSubscriptionStatus() {
            if (!publicKey || !pool) {
                log('Cannot check subscription status - no key or pool', 'warning');
                return;
            }
            
            log('Checking subscription status...', 'info');
            
            try {
                // Query for the user's subscription events (kinds 3081 and 3082)
                // 3081 = subscription upsert, 3082 = subscription delete
                const events = await pool.querySync([relayUrl], {
                    authors: [publicKey],
                    kinds: [3081, 3082],
                    limit: 10
                });
                
                if (events.length === 0) {
                    log('No subscription events found', 'info');
                    updateSubUI(false);
                    return;
                }
                
                // Sort by created_at to get the most recent event
                events.sort((a, b) => b.created_at - a.created_at);
                const latestEvent = events[0];
                
                // Kind 3081 = subscribe, Kind 3082 = unsubscribe
                const isSubscribed = latestEvent.kind === 3081;
                
                log(`Latest subscription event: kind ${latestEvent.kind} at ${new Date(latestEvent.created_at * 1000).toLocaleString()}`, 'info');
                
                if (isSubscribed) {
                    // Check what filters they're subscribed to
                    const filterTag = latestEvent.tags.find(tag => tag[0] === 'filter');
                    if (filterTag) {
                        log(`Subscribed with filter: ${filterTag[1]}`, 'info');
                    }
                }
                
                updateSubUI(isSubscribed);
                
            } catch (error) {
                log(`Error checking subscription status: ${error.message}`, 'error');
            }
        }

        function updateSubUI(subscribed) {
            const badge = document.getElementById('subStatus');
            const subscribeBtn = document.getElementById('subscribe');
            const unsubscribeBtn = document.getElementById('unsubscribe');
            
            if (subscribed) {
                badge.textContent = 'Subscribed';
                badge.className = 'status-badge active';
                // When subscribed, disable subscribe button and enable unsubscribe
                if (isRegistered) {
                    subscribeBtn.disabled = true;
                    unsubscribeBtn.disabled = false;
                }
            } else {
                badge.textContent = 'Not Subscribed';
                badge.className = 'status-badge inactive';
                // When not subscribed, enable subscribe button and disable unsubscribe
                if (isRegistered) {
                    subscribeBtn.disabled = false;
                    unsubscribeBtn.disabled = true;
                }
            }
        }

        async function updateServiceWorkerCount() {
            if ('serviceWorker' in navigator) {
                const registrations = await navigator.serviceWorker.getRegistrations();
                document.getElementById('swCount').textContent = registrations.length;
            }
        }

        function log(message, type = 'info') {
            const time = new Date().toLocaleTimeString('en-US', { 
                hour12: false, 
                hour: '2-digit', 
                minute: '2-digit', 
                second: '2-digit' 
            });
            
            const logs = document.getElementById('logs');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${time}] ${message}`;
            logs.appendChild(entry);
            logs.scrollTop = logs.scrollHeight;
            
            // Keep only last 50 entries
            while (logs.children.length > 50) {
                logs.removeChild(logs.firstChild);
            }
        }
    </script>
</body>
</html>